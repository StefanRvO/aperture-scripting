local gerber = require 'gerber'

local files = {}

local scale = { x = 1, y = 1 }
local offset = { x = 0, y = 0 }

local args = {...}
local i = 1
while i <= #args do
	local arg = args[i]
	if arg=='-offset' then
		i = i + 1
		assert(i <= #args, "-offset need an argument")
		local sx,x,sy,y = args[i]:match('^([+-])([%d.]+)([+-])([%d.]+)$')
		assert(sx and x and sy and y)
		x,y = tonumber(x),tonumber(y)
		assert(x and y)
		if sx=='-' then x = -x end
		if sy=='-' then y = -y end
		offset = { x = x, y = y }
	elseif arg=='-scale' then
		i = i + 1
		assert(i <= #args, "-scale need an argument")
		local sx,x,sy,y = args[i]:match('^([+-])([%d.]+)([+-])([%d.]+)$')
		assert(sx and x and sy and y)
		x,y = tonumber(x),tonumber(y)
		assert(x and y)
		if sx=='-' then x = -x end
		if sy=='-' then y = -y end
		scale = { x = x, y = y }
	elseif arg:match('^%-') then
		error("unknown option "..arg)
	else
		table.insert(files, {filename=arg, scale=scale, offset=offset})
	end
	i = i + 1
end

local output = files[#files].filename
files[#files] = nil

-- load files
for _,file in ipairs(files) do
	file.gerber = assert(gerber.load(file.filename))
end

-- ignore empty files
local i = #files
while i >= 1 do
	if #files[i].gerber == 0 then
		files[i] = files[#files]
		files[#files] = nil
	end
	i = i - 1
end

assert(#files >= 1)

-- reference gerber to make sure all merged files are similar enough
local reference = files[1].gerber

-- check they are simple enough to merge
for _,file in ipairs(files) do
	-- check format
	assert(tostring(file.gerber.format) == tostring(reference.format))
	-- check all the file directive parameters are in the reference
	for name,parameter in pairs(file.gerber.parameters) do
		assert(reference.parameters[name])
		assert(tostring(reference.parameters[name]) == tostring(parameter))
	end
	-- check all the reference directive parameters are in the file
	for name in pairs(reference.parameters) do
		assert(file.gerber.parameters[name])
	end
	-- check all the file image parameters are in the reference
	for name,parameter in pairs(file.gerber.image) do
		assert(reference.image[name])
		assert(tostring(reference.image[name]) == tostring(parameter))
	end
	-- check all the reference image parameters are in the file
	for name in pairs(reference.image) do
		assert(file.gerber.image[name])
	end
end

-- apply scale and offset
for _,file in ipairs(files) do
	for _,block in ipairs(file.gerber) do
		if block.type=='directive' then
			if block.X then
				block.X = block.X * file.scale.x + file.offset.x
			end
			if block.Y then
				block.Y = block.Y * file.scale.y + file.offset.y
			end
		end
	end
	-- :TODO: scale macros and apertures
end

-- merge macros and aperture definitions
local macros = {}
local rmacros = {}
local apertures = {}
local rapertures = {}
for _,file in ipairs(files) do
	-- add each macro to the merged list
	for name,macro in pairs(file.gerber.macros) do
		local data = table.concat(macro, '\0')
		local existing = rmacros[data]
		if existing then
			if existing ~= name then
				-- :TODO: change every aperture of this file using <name> to <existing>
				error("merging of identical macros is not yet supported")
			end
		elseif macros[name] then
			-- :TODO: rename macro
			error("renaming of conflicting macros is not yet supported")
		else
			macros[name] = macro
			rmacros[data] = name
		end
	end
	-- add each aperture to the merged list
	local amapping = {}
	for dcode,aperture in pairs(file.gerber.apertures) do
		local data = aperture.definition
		local existing = rapertures[data]
		if existing then
			if existing ~= dcode then
				-- change every directive of this file using <dcode> to <existing>
				amapping[dcode] = existing
			end
		elseif apertures[dcode] then
			-- rename aperture
			local dcode2 = dcode + 1
			while apertures[dcode2] do
				dcode2 = dcode2 + 1
			end
			amapping[dcode] = dcode2
			apertures[dcode2] = aperture
			rapertures[data] = dcode2
		else
			apertures[dcode] = aperture
			rapertures[data] = dcode
		end
	end
	-- apply aperture mergings
	for _,block in ipairs(file.gerber) do
		if block.type=='directive' and amapping[block.D] then
			block.D = amapping[block.D]
		elseif block.type=='aperture' and amapping[block.dcode] then
			block.dcode = amapping[block.dcode]
		end
	end
end

-- rename layers
for ifile,file in ipairs(files) do
	for _,block in ipairs(file.gerber) do
		if block.type=='parameter' and block.name=='LN' then
			local layer = block.value
			assert(layer)
			layer = "FILE"..ifile.."_"..layer
			block.value = layer
		end
	end
end

-- merge file
local data = {}

local merged = false
for ifile,file in ipairs(files) do
	table.insert(data, gerber.comment(" data from file "..file.filename))
	for _,block in ipairs(file.gerber) do
		if block.type=='directive' then
			if block.M ~= 2 then
				table.insert(data, block)
			end
		else
			if block.scope == 'layer' or ifile == 1 then
				-- replace the first aperture or macro by the merged lists
				if block.type=='aperture' or block.type=='macro' then
					-- ignore subsequent aperture/macro blocks
					if not merged then
						for _,macro in pairs(macros) do
							table.insert(data, macro)
						end
						for _,aperture in pairs(apertures) do
							table.insert(data, aperture)
						end
						merged = true
					end
				else
					table.insert(data, block)
				end
			end
		end
	end
end

-- save output file
assert(gerber.save(data, output))

-- vi: ft=lua
