<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
lang="en">
<head>
<title>Gerber-ltools</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link rel="stylesheet" href="doc.css" type="text/css"/>
</head>
<body>

<div class="chapter" id="header">
<img width="128" height="128" alt="Gerber-ltools" src="logo.png"/>
<p>A set of libraries and tools to manipulate PCB data files</p>
<p class="bar">
<a href="index.html">home</a> &middot;
<a href="index.html#download">download</a> &middot;
<a href="index.html#installation">installation</a> &middot;
<a href="manual.html">manual</a> &middot;
<a href="examples.html">examples</a>
</p>
</div>

<div class="chapter">
<a id="examples"/><h1>5 - Examples</h1>

<p>Here are some progressively more complex example scripts showing how you can use gerber-ltools.</p>

<h2>5.1 - Loading a board</h2>

<p>The first step when using gerber-ltools usually consist in loading some board that you exported from your CAD software. First you need to load the <code>boards</code> module:</p>

<pre><code>local boards = require 'boards'
</code></pre>

<p>Then to load a board you use the <code>boards.load</code> function:</p>

<pre><code>local simple = assert(boards.load('./simple'))
</code></pre>

<p>This will simply print all the corresponding Gerber and Excellon file names, and validate the data (ie. if there is some loading error, you should get an error message). In all examples below we start from this <em>simple</em> board, which looks like this:</p>

<p><img src="examples/simple.png" alt=""/></p>

<h2>5.2 - Saving a board</h2>

<p>The final step of any manipulation script usually involves saving your board data. The function to call is <code>boards.save</code>:</p>

<pre><code>local simple = assert(boards.load('./simple'))

assert(boards.save(simple, './save'))
</code></pre>

<p>As expected the output is identical to the input:</p>

<p><img src="examples/save.png" alt=""/></p>

<h2>5.3 - Rotating a board</h2>

<p>One common manipulation of boards consist in rotating them, for example because they are not square and better fit in another direction. Rotation and most manipulation are in the <code>boards.manipulation</code> module:</p>

<pre><code>local manipulation = require 'boards.manipulation'
</code></pre>

<p>To rotate a board call <code>manipulation.rotate_board</code> with the board and a direct angle value in degrees as arguments:</p>

<pre><code>local rotate = manipulation.rotate_board(simple, 90)

assert(boards.save(rotate, './rotate'))
</code></pre>

<p>The result is the same board as above, but rotated 90Â°:</p>

<p><img src="examples/rotate.png" alt=""/></p>

<h2>5.5 - Panelizing boards</h2>

<p>One of the most important features of gerber-ltools is its ability to panelize boards, ie. to assemble several boards into a larger one. This is probably why you want to use gerber-ltools. The module you need for that is <code>boards.panelization</code>:</p>

<pre><code>local panelization = require 'boards.panelization'
</code></pre>

<p>There you will find a <code>panelization.panelize</code> function that receives a layout table, an options table, a top-level orientation and that returns a new board object for the panel.</p>

<pre><code>local simple = assert(boards.load('./simple'))

local layout = { simple, simple }

local panel = assert(panelization.panelize(layout, {}, true))

boards.merge_apertures(panel)
assert(boards.save(panel, './panel'))
</code></pre>

<p>Here the layout contains two copies of the <em>simple</em> board. These are actually Lua references, but since we don't modify them during panelization you can reuse the same board object several times. The options table is empty to use the defaults. The third argument <code>true</code> means the panel top-level is vertical. We're making a vertical panel because the <em>simple</em> board has a slot on its left side which would prevent the insertion of a break tab.</p>

<p>The resulting panel looks like that:</p>

<p><img src="examples/panel.png" alt=""/></p>

<p>As you can see the <code>panelize</code> function automatically placed the sub-boards with a 2 mm gap, and it created a break tab to connect the two boards.</p>

<h2>5.6 - Panelizing modified boards</h2>

<p>Of course you can combine the above operations to first modify the board, and then use the modified copy in a panel. Since our <em>simple</em> board has a slot on its left, we'll create a rotated copy with the slot on the right, so that we can create an horizontal panel.</p>

<pre><code>local simple = assert(boards.load('./simple'))
local simple180 = manipulation.rotate_board(simple, 180)

local layout = { simple, simple180 }

local panel = assert(panelization.panelize(layout, {}, false))

boards.merge_apertures(panel)
assert(boards.save(panel, './panel2'))
</code></pre>

<p>As we have seen above the <code>rotate_board</code> function returns the rotated board. This means the original board is left intact, and we can use both in the panel. Generally the functions in the <code>boards.manipulation</code> module will create copies of the input data, which is kept unmodified.</p>

<p>This time we passed <code>false</code> as third argument to <code>panelize</code>, which means we want a horizontal panel. The result of this panel is as follows:</p>

<p><img src="examples/panel2.png" alt=""/></p>

<p>To verify that the right board has been rotated and not mirrored, you can check the little hole in the trace, which the left board has on the top-right, but which the right board has on the bottom-left.</p>

<h2>5.7 - Panelizing in two dimensions</h2>

<p>We've seen above that the <code>panelize</code> function takes a panel layout as argument. A layout is a Lua array, so it can only have one dimension (either vertical or horizontal depending on the <code>panelize</code> third argument). But each element of the array can be either a board, or another sub-panel layout. This is how you construct complex panels recursively. As you can guess this limits the kind of panels you can create. To access a single board you always break the panel in two along a single line, several times if necessary depending on the layout depth. This has advantages (panel separation is easy) but also drawbacks (e.g. you cannot completely surround your panel with a rectangle frame to improve its stiffness).</p>

<p>Here is an example script with a two level layout:</p>

<pre><code>local simple = assert(boards.load('./simple'))
local simple90 = manipulation.rotate_board(simple, 90)
local simple180 = manipulation.rotate_board(simple, 180)
local simple270 = manipulation.rotate_board(simple, 270)

local layout = {
    { simple90, simple180 },
    { simple, simple270 },
}

local panel = assert(panelization.panelize(layout, {}, true))

boards.merge_apertures(panel)
assert(boards.save(panel, './panel3'))
</code></pre>


<p>Each level of the layout has to be made of boards with the same size along the alignment direction. For a horizontal layout, all boards must be the same height. For a vertical layout, all boards must be the same width. Here our <em>simple</em> board is a square, so even rotated it will always have the same size on both axis.</p>

<p>Another thing to keep in mind is that the layout describe panels from left to right, and from bottom to top. This means in the example above, the first sub-panel with <code>simple90</code> and <code>simple180</code> will actually be on the bottom of the output panel.</p>

<p>The resulting 2D panels looks like this:</p>

<p><img src="examples/panel3.png" alt=""/></p>

<p>As we've seen before there is only one breaking tab between the left and right part of each sub-panel, but there are two between the top and bottom sub-panels. This is because the <code>panelize</code> function will insert breaking tabs in each segment of sub-panel edge that match on both sides of the gap, and sometimes more along long edges.</p>

<h2>5.8 - Creating boards</h2>

<p>Sometimes you not only want to manipulate and assemble existing boards, but you may want to create new boards on the fly. For example you may want to put spacers between boards in a panel to account for over-hanging components, or you might want to add a frame with tooling holes and fiduciaries.</p>

<p>The <code>panelization</code> module has a function named <code>empty_board</code> that lets you create such an empty board. You can either pass dimensions so that your board is created with a rectangle outline, or call the function without arguments to get a completely empty board without dimensions (to be used as a canvas for drawing, see below).</p>


</div>

<div class="chapter" id="footer">
<small>Last update: 2014-07-18 20:15:08 BST</small>
</div>

</body>
</html>

