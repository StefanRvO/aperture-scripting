local _M = {}

local io = require 'io'
local math = require 'math'
local table = require 'table'
local lfs = require 'lfs'
local pathlib = require 'path'
local dump = require 'dump'

local region = require 'boards.region'
local drawing = require 'boards.drawing'
local extents = require 'boards.extents'
local aperture = require 'boards.aperture'
local templates = require 'boards.templates'
local pathmerge = require 'boards.pathmerge'
local manipulation = require 'boards.manipulation'
local panelization = require 'boards.panelization'
local interpolation = require 'boards.interpolation'

pathlib.install()

local unpack = unpack or table.unpack

------------------------------------------------------------------------------

_M.circle_steps = 64

------------------------------------------------------------------------------

local path_load_scales = {
	pm = 1,
	mm = 1e-9,
}

local path_merge_scales = {
	pm = 1e9,
	mm = 1,
}

local function load_image(filepath, format, unit, template)
	print("loading "..tostring(filepath))
	local image
	if format=='excellon' then
		local excellon = require 'excellon'
		image = excellon.load(filepath)
	elseif format=='bom' then
		local bom = require 'bom'
		image = bom.load(filepath, template.bom)
	elseif format=='gerber' then
		local gerber = require 'gerber'
		image = gerber.load(filepath)
	elseif format=='svg' then
		local svg = require 'svg'
		image = svg.load(filepath)
	elseif format=='dxf' then
		local dxf = require 'dxf'
		image = dxf.load(filepath)
	else
		error("unsupported image format "..tostring(format))
	end
	
	-- scale the path data (sub-modules output picometers)
	local scale = assert(path_load_scales[unit], "unsupported board output unit "..tostring(unit))
	if scale ~= 1 then
		for _,layer in ipairs(image.layers) do
			for _,path in ipairs(layer) do
				for _,point in ipairs(path) do
					point.x = point.x * scale
					point.y = point.y * scale
					if point.cx then point.cx = point.cx * scale end
					if point.cy then point.cy = point.cy * scale end
				end
			end
		end
	end
	
	-- merge quasi-continuous paths (like rounded outlines as generated by EAGLE)
	local path_merge_epsilon = (template.path_merge_radius or 0) * path_merge_scales[unit]
	pathmerge.merge_image_paths(image, path_merge_epsilon)
	
	return image
end

function _M.load_image(filepath, format, options)
	if not options then options = {} end
	
	local unit = options.unit or 'pm'
	local template = templates.default -- :TODO: make that configurable
	
	if not format then
		local msg
		format,msg = _M.detect_format(filepath)
		if not format then
			return nil,msg
		end
	end
	
	return load_image(filepath, format, unit, template)
end

local function save_image(image, filepath, format, unit, template)
	print("saving "..tostring(filepath))
	assert(unit == 'pm', "saving scaled images is not yet supported")
	if format=='excellon' then
		local excellon = require 'excellon'
		return excellon.save(image, filepath)
	elseif format=='bom' then
		local bom = require 'bom'
		return bom.save(image, filepath, template.bom)
	elseif format=='gerber' then
		local gerber = require 'gerber'
		return gerber.save(image, filepath)
	elseif format=='svg' then
		local svg = require 'svg'
		return svg.save(image, filepath)
	elseif format=='dxf' then
		local dxf = require 'dxf'
		return dxf.save(image, filepath)
	else
		error("unsupported image format "..tostring(format))
	end
end

function _M.save_image(image, filepath, format, options)
	if not options then options = {} end
	
	local unit = options.unit or 'pm'
	local template = templates.default -- :TODO: make that configurable
	
	return save_image(image, filepath, format, unit, template)
end

------------------------------------------------------------------------------

local function path_to_region(path)
	-- find bottom-left corner
	local exterior = region.exterior(path)
	local reversible = true
	local corner = 1
	for i=2,#path-1 do
		if path[i].interpolated or path[i].interpolation~='linear' then
			reversible = false
		end
		if path[i].y < path[corner].y or path[i].y == path[corner].y and path[i].x < path[corner].x then
			corner = i
		end
	end
	
	local corner_interpolation = corner==1 and path[#path].interpolation or path[corner].interpolation
	
	local region = {}
	
	if path[corner].interpolated or corner_interpolation~='linear' or not exterior and not reversible then
		-- don't alter the path (which will prevent panelization)
		for _,point in ipairs(path) do
			table.insert(region, point)
		end
	else
		if not exterior then
			-- if we're here, it means reversible is true, which means we're all linear interpolation
			for i=corner,1,-1 do
				table.insert(region, {x=path[i].x, y=path[i].y, interpolation='linear'})
			end
			for i=#path-1,corner,-1 do
				table.insert(region, {x=path[i].x, y=path[i].y, interpolation='linear'})
			end
			region[1].interpolation = nil
		else
			table.insert(region, {x=path[corner].x, y=path[corner].y})
			for i=corner+1,#path do
				table.insert(region, path[i])
			end
			for i=2,corner do
				table.insert(region, path[i])
			end
		end
	end
	
	return region
end

function _M.detect_format(path)
	local file,msg = io.open(path, 'rb')
	if not file then return nil,msg end
	local k,msg = file:read(1024)
	if not k then file:close(); return nil,msg end
	local success,msg = file:close()
	if not success then return nil,msg end
	if k:match('FS[LT][AI]X%d%dY%d%d%*') or k:match('%%ADD10') then
		return 'gerber'
	elseif k:match('T01') or k:match('M48') then
		return 'excellon'
	elseif k:match('%s+0%s+SECTION%s') then
		return 'dxf'
	elseif k:match('^[^\n]*\t[^\n]*\n') then
		return 'bom'
	else
		return nil,"unknown file format"
	end
end

function _M.load(path, options)
	if not options then options = {} end
	
	local board = {}
	
	board.unit = options.unit or 'pm'
	
	-- look for a template
	local template
	-- - 1. look for a .conf file in the input
	if type(path)=='string' and lfs.attributes(path, 'mode') and path:match('%.conf$') then
		template = dofile(path)
	elseif type(path)=='string' and lfs.attributes(path..".conf", 'mode') then
		template = dofile(path..".conf")
	elseif type(path)=='table' then
		for _,path in ipairs(path) do
			if lfs.attributes(path, 'mode') and path:match('%.conf$') then
				template = dofile(path)
				break
			end
		end
	end
	-- - 2. try option as a filename
	if not template and options.template and lfs.attributes(options.template, 'mode') then
		template = dofile(options.template)
	end
	-- - 3. try option as standard template name
	if not template and options.template and templates[options.template] then
		template = templates[options.template]
	end
	-- - 4. use default template
	if not template then
		template = templates.default -- :TODO: make that configurable
	end
	
	if not template then
		return nil,"no template found"
	end
	board.template = template
	
	-- single file special case
	if type(path)=='string' and lfs.attributes(path, 'mode') then
		path = { path }
	end
	
	-- locate files
	local paths = {}
	local extensions = {}
	if type(path)~='table' and lfs.attributes(path, 'mode') then
		path = { path }
	end
	if type(path)=='table' then
		for _,path in ipairs(path) do
			path = pathlib.split(path)
			local found = false
			for image,patterns in pairs(template.patterns) do
				if type(patterns)=='string' then patterns = { patterns } end
				for _,pattern in ipairs(patterns) do
					local lpattern = '^'..pattern:gsub('[-%.()%%]', {
						['-'] = '%-',
						['.'] = '%.',
						['('] = '%(',
						[')'] = '%)',
						['%'] = '(.*)',
					})..'$'
					local basename = path.file:match(lpattern) or path.file:lower():match(lpattern:lower())
					if basename then
						paths[image] = path
						extensions[image] = pattern
						found = true
						break
					end
				end
				if found then
					break
				end
			end
			if not found then
				print("cannot guess type of file "..tostring(path))
			end
		end
	else
		path = pathlib.split(path)
		local files = {}
		for file in lfs.dir(path.dir) do
			files[file:lower()] = file
		end
		for image,patterns in pairs(template.patterns) do
			if type(patterns)=='string' then patterns = { patterns } end
			for _,pattern in ipairs(patterns) do
				local file = files[pattern:gsub('%%', path.file):lower()]
				if file then
					paths[image] = path.dir / file
					extensions[image] = pattern
					break
				end
			end
		end
	end
	if next(paths)==nil then
		return nil,"no image found"
	end
	board.extensions = extensions
	
	-- load images
	local images = {}
	local formats = {}
	for type,path in pairs(paths) do
		local format = assert(_M.detect_format(path), "could not detect format of file "..tostring(path))
		local image = load_image(path, format, board.unit, template)
		images[type] = image
		formats[type] = format
	end
	board.images = images
	board.formats = formats
	
	-- extract outline
	local outlines = _M.find_board_outlines(board)
	if next(outlines) and not options.keep_outlines_in_images then
		local data = select(2, next(outlines))
		local outline = {}
		outline.path = path_to_region(data.path)
		outline.apertures = {}
		-- convert the outline data
		for type,data in pairs(outlines) do
			-- store the aperture used on this image
			outline.apertures[type] = data.path.aperture
			-- remove the path from the image
			table.remove(board.images[type].layers[data.ilayer], data.ipath)
			if #board.images[type].layers[data.ilayer] == 0 then
				table.remove(board.images[type].layers, data.ilayer)
			end
		end
		board.outline = outline
	end
	
	return board
end

function _M.save(board, filepath)
	if pathlib.type(filepath) ~= 'path' then
		filepath = pathlib.split(filepath)
	end
	for type,image in pairs(board.images) do
		-- re-inject outline before saving
		if board.outline and board.outline.apertures[type] then
			image = manipulation.copy_image(image)
			local path = manipulation.copy_path(board.outline.path)
			path.aperture = board.outline.apertures[type]
			if #image.layers==0 or image.layers[#image.layers].polarity=='clear' then
				table.insert(image.layers, {polarity='dark'})
			end
			table.insert(image.layers[#image.layers], path)
		end
		local pattern = assert(board.extensions[type], "no extension pattern for file of type "..type)
		local filepath = filepath.dir / pattern:gsub('%%', filepath.file)
		local format = assert(board.formats[type], "no format for file of type "..type)
		local success,msg = save_image(image, filepath, format, board.unit, board.template)
		if not success then return nil,msg end
	end
	return true
end

------------------------------------------------------------------------------

local function find_image_outline(image)
	-- find path with largest area
	local amax,lmax,pmax = -math.huge
	for l,layer in ipairs(image.layers) do
		for p,path in ipairs(layer) do
			local path_extents = extents.compute_path_extents(path)
			local a = path_extents.area
			if a > amax then
				amax,lmax,pmax = a,l,p
			end
		end
	end
	-- check that we have a path
	if not lmax or not pmax then
		return nil
	end
	local path = image.layers[lmax][pmax]
	-- check that the path is long enough to enclose a region
	if #path < 3 then
		return nil
	end
	-- check that the path is closed
	if path[1].x ~= path[#path].x or path[1].y ~= path[#path].y then
		return nil
	end
	-- check that path is a line, not a region
	if not path.aperture then
		return nil
	end
	-- :TODO: check that all other paths are within the outline
	
	return path,amax,lmax,pmax
end

local ignore_outline = {
	top_soldermask = true,
	bottom_soldermask = true,
}
_M.ignore_outline = ignore_outline

function _M.find_board_outlines(board)
	local outlines = {}
	-- gen raw list
	local max_area = -math.huge
	for type,image in pairs(board.images) do
		if not ignore_outline[type] then
			local path,area,ilayer,ipath = find_image_outline(image)
			if path then
				max_area = math.max(max_area, area)
				outlines[type] = {path=path, ilayer=ilayer, ipath=ipath, area=area}
			end
		end
	end
	-- filter the list
	for type,data in pairs(outlines) do
		-- igore all but the the largest ones
		if data.area < max_area then
			outlines[type] = nil
		end
	end
	return outlines
end

------------------------------------------------------------------------------

local function macro_hash(macro)
	local t = {}
	for _,instruction in ipairs(macro.script) do
		local type = instruction.type
		table.insert(t, type)
		if type=='comment' then
			-- ignore
		elseif type=='variable' then
			table.insert(t, instruction.name)
			table.insert(t, instruction.expression)
		elseif type=='primitive' then
			table.insert(t, instruction.shape)
			for _,expression in ipairs(instruction.parameters) do
				table.insert(t, expression)
			end
		else
			error("unsupported aperture macro instruction type "..tostring(type))
		end
	end
	return table.concat(t, '\0')
end

local function aperture_hash(aperture)
	local t = {shape}
	if aperture.macro then
		table.insert(t, 'macro')
		table.insert(t, macro_hash(aperture.macro))
	elseif aperture.shape then
		local shape = aperture.shape
		if shape=='circle' then
			table.insert(t, aperture.diameter)
			table.insert(t, aperture.hole_width)
			table.insert(t, aperture.hole_height)
		elseif shape=='rectangle' or shape=='obround' then
			table.insert(t, aperture.width)
			table.insert(t, aperture.height)
			table.insert(t, aperture.hole_width)
			table.insert(t, aperture.hole_height)
		elseif shape=='polygon' then
			table.insert(t, aperture.diameter)
			table.insert(t, aperture.steps)
			table.insert(t, aperture.angle)
			table.insert(t, aperture.hole_width)
			table.insert(t, aperture.hole_height)
		else
			error("unsupported aperture shape "..tostring(shape))
		end
	elseif aperture.device then
		local keys = {}
		for k in pairs(aperture.parameters) do
			table.insert(keys, k)
		end
		table.sort(keys)
		for _,k in ipairs(keys) do
			table.insert(t, k)
			table.insert(t, aperture.parameters[k])
		end
	else
		error("unsupported aperture")
	end
	return table.concat(t, '\0')
end

local function merge_image_apertures(image)
	-- list apertures
	local apertures = {}
	local aperture_order = {}
	for _,layer in ipairs(image.layers) do
		for _,path in ipairs(layer) do
			local aperture = path.aperture
			if aperture then
				local s = aperture_hash(aperture)
				if apertures[s] then
					aperture = apertures[s]
					path.aperture = aperture
				else
					apertures[s] = aperture
					table.insert(aperture_order, aperture)
				end
			end
		end
	end
	
	-- list macros
	local macros = {}
	local macro_order = {}
	for _,aperture in ipairs(aperture_order) do
		local macro = aperture.macro
		if macro then
			local s = macro_hash(macro)
			if macros[s] then
				aperture.macro = macros[s]
			else
				macros[s] = macro
				table.insert(macro_order, macro)
			end
		end
	end
end
_M.merge_image_apertures = merge_image_apertures

local function merge_board_apertures(board)
	for _,image in pairs(board.images) do
		merge_image_apertures(image)
	end
end

function _M.merge_apertures(board)
	merge_board_apertures(board)
end

------------------------------------------------------------------------------

function _M.generate_aperture_paths(board)
	-- collect apertures
	local apertures = {}
	for _,image in pairs(board.images) do
		for _,layer in ipairs(image.layers) do
			for _,path in ipairs(layer) do
				local aperture = path.aperture
				if aperture and not apertures[aperture] then
					apertures[aperture] = true
				end
			end
		end
	end
	
	-- generate aperture paths
	for a in pairs(apertures) do
		a.paths = aperture.generate_aperture_paths(a, board.unit, _M.circle_steps)
	end
end

------------------------------------------------------------------------------

local function round(value, epsilon)
	if not value then return value end
	if not epsilon then epsilon = 1 end
	return math.floor(value / epsilon + 0.5) * epsilon
end

local function round_image_paths(image, epsilon)
	for _,layer in ipairs(image.layers) do
		for _,path in ipairs(layer) do
			local interpolated = { aperture = path.aperture }
			for _,point in ipairs(path) do
				for _,k in ipairs{'x', 'y', 'cx', 'cy'} do
					point[k] = round(point[k], epsilon)
				end
			end
		end
	end
end
_M.round_image_paths = round_image_paths

------------------------------------------------------------------------------

local function value_to_pm(value, unit)
	assert(value:match('^(%d+)%.(%d+)$') or value:match('^(%d+)$'), "malformed number '"..value.."'")
	if unit=='pm' then
		return assert(tonumber(value), "number conversion failed")
	elseif unit=='mm' then
		-- simply move the dot 9 digits to the right
		local i,dm = value:match('^(%d+)%.(%d+)$')
		local dp
		if i and dm then
			if #dm < 9 then
				dp = '0'
				dm = dm..string.rep('0', 9 - #dm)
			else
				dp = dm:sub(10)
				dm = dm:sub(1, 9)
			end
		else
			i = value
			dp = '0'
			dm = '000000000'
		end
		return assert(tonumber(i..dm..'.'..dp), "number conversion failed")
	elseif unit=='in' then
		-- move the dot 8 digits to the right, and multiply by 254
		local i,dm = value:match('^(%d+)%.(%d+)$')
		local dp
		if i and dm then
			if #dm < 8 then
				dp = '0'
				dm = dm..string.rep('0', 8 - #dm)
			else
				dp = dm:sub(9)
				dm = dm:sub(1, 8)
			end
		else
			i = value
			dp = '0'
			dm = '00000000'
		end
		return 254 * assert(tonumber(i..dm..'.'..dp), "number conversion failed")
	else
		error("invalid unit '"..tostring(unit).."'")
	end
end

function _M.parse_distances(str)
	local numbers = {}
	for sign,value,unit in str:gmatch('([+-]?)([%d.]+)(%w*)') do
		if unit=='' then unit = 'mm' end
		local n = value_to_pm(value, unit)
		if sign=='-' then n = -n end
		table.insert(numbers, n)
	end
	return table.unpack(numbers)
end

------------------------------------------------------------------------------

return _M
