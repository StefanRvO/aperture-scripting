local excellon = require 'excellon'

local files = {}

local offset = { x = 0, y = 0 }

local args = {...}
local i = 1
while i <= #args do
	local arg = args[i]
	if arg=='-offset' then
		i = i + 1
		assert(i <= #args, "-offset need an argument")
		local sx,x,sy,y = args[i]:match('^([+-])([%d.]+)([+-])([%d.]+)$')
		assert(sx and x and sy and y)
		x,y = tonumber(x),tonumber(y)
		assert(x and y)
		if sx=='-' then x = -x end
		if sy=='-' then y = -y end
		offset = { x = x, y = y }
	elseif arg:match('^%-') then
		error("unknown option "..arg)
	else
		table.insert(files, {filename=arg, offset=offset})
	end
	i = i + 1
end

local output = files[#files].filename
files[#files] = nil

assert(#files >= 1)

-- load files
for _,file in ipairs(files) do
	file.excellon = assert(excellon.load(file.filename))
end

-- reference excellon to make sure all merged files are similar enough
local reference = files[1].excellon

-- check they are similar enough to merge
for _,file in ipairs(files) do
	-- check all the file parameters are in the reference
	for name,parameter in pairs(file.excellon.parameters) do
		assert(reference.parameters[name])
	end
	-- check all the reference parameters are in the file
	for name in pairs(reference.parameters) do
		assert(file.excellon.parameters[name])
	end
end

-- merge tool definitions
local tools = {}
local rtools = {}
for _,file in ipairs(files) do
	-- add each tool to the merged list
	local tmapping = {}
	for tcode,tool in pairs(file.excellon.tools) do
		local data = tool.definition
		local existing = rtools[data]
		if existing then
			if existing ~= tcode then
				-- change every directive of this file using <tcode> to <existing>
				tmapping[tcode] = existing
			end
		elseif tools[tcode] then
			-- rename tool
			local tcode2 = tcode + 1
			while tools[tcode2] do
				tcode2 = tcode2 + 1
			end
			tmapping[tcode] = tcode2
			tools[tcode2] = tool
			rtools[data] = tcode2
		else
			tools[tcode] = tool
			rtools[data] = tcode
		end
	end
	-- apply tool mergings
	for _,block in ipairs(file.excellon.headers) do
		if block.type=='tool' and tmapping[block.tcode] then
			block.tcode = tmapping[block.tcode]
		end
	end
	for _,block in ipairs(file.excellon) do
		if block.type=='directive' and tmapping[block.T] then
			block.T = tmapping[block.T]
		end
	end
end

-- apply offsets
for _,file in ipairs(files) do
	for _,block in ipairs(file.excellon) do
		if block.type=='directive' then
			if block.X then
				block.X = block.X + file.offset.x
			end
			if block.Y then
				block.Y = block.Y + file.offset.y
			end
		end
	end
end

--[===[

-- rename layers
for ifile,file in ipairs(files) do
	for _,block in ipairs(file.gerber) do
		if block.type=='parameter' and block.name=='LN' then
			local layer = block.block:match('^LN(.*)$')
			assert(layer)
			layer = "FILE"..ifile.."_"..layer
			block.block = 'LN'..layer
		end
	end
end

--]===]

-- merge file
local data = { headers = {} }

local merged = false
for _,header in ipairs(reference.headers) do
	if header.type=='tool' then
		if not merged then
			for _,tool in pairs(tools) do
				table.insert(data.headers, tool)
			end
			merged = true
		end
	else
		table.insert(data.headers, header)
	end
end
for ifile,file in ipairs(files) do
	for _,block in ipairs(file.excellon) do
		if block.type~='directive' or block.M ~= 30 then
			table.insert(data, block)
		end
	end
end

-- save output file
assert(excellon.save(data, output))

-- vi: ft=lua
